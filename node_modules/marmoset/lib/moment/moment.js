/*******************************************************************
 * used to support plugins
 ********************************************************************/

"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _typevalidator = require("typevalidator");

var _typevalidator2 = _interopRequireDefault(_typevalidator);

var _emmiter = require("./emmiter");

var _emmiter2 = _interopRequireDefault(_emmiter);

var getTypeChecker = function getTypeChecker(specialMetas) {
    return (0, _typevalidator2["default"])({
        "legalTriggerEvent": function legalTriggerEvent(v) {
            for (var i = 0; i < specialMetas.length; i++) {
                if (v.indexOf(specialMetas[i]) !== -1) {
                    return false;
                }
            }
            return true;
        },
        "functionList": function functionList(v) {
            for (var i = 0; i < v.length; i++) {
                var item = v[i];
                if (typeof item !== "function") {
                    return false;
                }
            }
            return true;
        }
    });
};

var getFormatType = function getFormatType(specialMetas) {
    return function (type) {
        type = type.trim();
        for (var i = 0; i < specialMetas.length; i++) {
            var specialMeta = specialMetas[i];
            var parts = type.split(specialMeta);
            for (var j = 0; j < parts.length; j++) {
                var part = parts[j];
                parts[j] = part.trim();
            }
            type = parts.join(specialMeta);
        }
        return type;
    };
};

var checkOpts = function checkOpts(typeChecker, opts) {
    typeChecker.checkBatch(["falsy | array", "falsy | (array & functionList)", "falsy | (array & functionList)"], [opts.triggerModels, opts.onModels, opts.onGroupModels]);

    for (var i = 0; i < opts.triggerModels.length; i++) {
        typeChecker.checkBatch(["string", "function"], [opts.triggerModels[i].name, opts.triggerModels[i].action]);
    }
};

/**
 * opts
 *     specialMetas
 *     triggerModels
 *     onModels
 *     onGroupModels
 *
 */

exports["default"] = function () {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var emmiter = (0, _emmiter2["default"])();
    var specialMetas = opts.specialMetas || [];

    // init Type Checker
    var typeChecker = getTypeChecker(specialMetas);
    var formatType = getFormatType(specialMetas);
    //
    checkOpts(typeChecker, opts);

    var triggerModels = opts.triggerModels || [];
    var onModels = opts.onModels || [];
    var onGroupModels = opts.onGroupModels || [];
    /**
     * used to trigger a event, and send data through event.
     */
    var trigger = function trigger(ctx, type, data) {
        typeChecker.check("string & legalTriggerEvent", type);
        var eventStack = [];
        triggerEvent(ctx, type, data, eventStack);
    };

    var triggerEvent = function triggerEvent(ctx, type, data, eventStack, modelName) {
        // trigger this event
        var event = emmiter.trigger(ctx, type, data);
        eventStack.push({
            event: event,
            source: {
                modelName: modelName
            }
        });

        var triggerThrough = function triggerThrough(name) {
            return function (ctx, type, data) {
                triggerEvent(ctx, type, data, eventStack, name);
            };
        };

        // trigger models
        for (var i = 0; i < triggerModels.length; i++) {
            var triggerModel = triggerModels[i];
            triggerModel.action(event, triggerThrough(triggerModel.name), eventStack);
        }
    };

    var on = function on(ctx, type, handler) {
        typeChecker.checkBatch(["string", "function"], [type, handler]);
        type = formatType(type);

        // grammer for on, when on create events
        for (var i = 0; i < onModels.length; i++) {
            var onModel = onModels[i];
            onModel(ctx, type, handler);
        }
        return emmiter.on(ctx, type, handler);
    };

    var onGroup = function onGroup(ctxs, type, handler) {
        typeChecker.checkBatch(["string", "function"], [type, handler]);
        type = formatType(type);
        var last = ctxs[ctxs.length - 1];

        // grammer for onGroup, when onGroup create rules
        for (var i = 0; i < onGroupModels.length; i++) {
            var onGroupModel = onGroupModels[i];
            onGroupModel(ctxs, type, handler);
        }
        return emmiter.on(last, type, handler);
    };

    return {
        trigger: trigger,
        on: on,
        onGroup: onGroup,
        off: emmiter.off
    };
};

module.exports = exports["default"];