/**
 * support bubble for event
 *
 * Assume ctx1 is the parent of ctx2, when a event happened on ctx2,
 * ctx1 will happen this event too. This is event bubble.
 *
 *
 */

import Node from "./node";

let Face = (opNodeCtxList) => {
    let face = {};
    face.parent = (...y) => {
        parent.apply(undefined, y);
        return face;
    }
    face.children = (...y) => {
        children.apply(undefined, y);
        return face;
    }

    let parent = (childCtx, parentCtx) => {
        let childNode = opNodeCtxList.getNode(childCtx);
        let parentNode = opNodeCtxList.getNode(parentCtx);
        parentNode.addChild(childNode);
    }

    let children = (parentCtx, childCtxs) => {
        for (let i = 0; i < childCtxs.length; i++) {
            let childCtx = childCtxs[i];
            parent(childCtx, parentCtx);
        }
    }
    return face;
}

let OpNodeCtxList = (nodeCtxList) => {
    let getNode = (ctx) => {
        for (let i = 0; i < nodeCtxList.length; i++) {
            let nodeCtx = nodeCtxList[i];
            if (ctx === nodeCtx.ctx) return nodeCtx.node;
        }
        let node = new Node(ctx);
        nodeCtxList.push({
            ctx, node
        });
        return node;
    }

    let findNode = (ctx) => {
        for (let i = 0; i < nodeCtxList.length; i++) {
            let nodeCtx = nodeCtxList[i];
            if (ctx === nodeCtx.ctx) return nodeCtx.node;
        }
        return null;
    }
    return {
        getNode,
        findNode
    }
}

export default () => {

    /**
     * [(ctx, node)]
     */
    let nodeCtxList = [];
    let opNodeCtxList = OpNodeCtxList(nodeCtxList);
    let face = Face(opNodeCtxList);

    let triggerBubble = (event, triggerNewEvent, eventStack) => {
        let ctx = event.ctx;
        let node = opNodeCtxList.findNode(ctx);
        if (!node) return;
        let parent = node.getParent();
        if (!parent) return;
        if (event.isPropagationStopped()) return;
        if (happened(eventStack, parent.getData(), event.type)) return;
        triggerNewEvent(parent.getData(), event.type, event.data);
    }
    let relationship = (callback) => {
        callback && callback(face);
    }

    let happened = (eventStack, ctx, type) => {
        for (let i = 0; i < eventStack.length; i++) {
            let eventWrapper = eventStack[i];
            let name = eventWrapper.source.modelName;
            if (name === undefined || name === "bubble") {
                if (eventWrapper.event.ctx === ctx &&
                    eventWrapper.event.type === type) {
                    return true;
                }
            }
        }
        return false;
    }

    return {
        trigger: {
            name: "bubble",
            action: triggerBubble
        },
        builders: {
            relationship
        }
    }
}