/**
 *
 * TODO friendly exception
 *
 */


/**
 * SETMRule
 *
 * ruleType
 * filter
 * match
 * steps
 *
 * strict design for SETMRule calling
 */
import eventTypeChecker from "./eventTypeChecker";
import {
    TriggerEventRule, DataMergeRule, SETMRule
}
from "./timelineInterface";

/**
 *
 * @return
 * bws [ { filter, steps, match } ]
 * prs [ { filter, steps, match } ]
 **/
var getRules = function(setmRules, triggerEventRule, dataMergeRule) {
    let triggerEventMatch = getTriggerEventMatch(triggerEventRule);
    let dataMergeHandler = getDataMergeRule(dataMergeRule);

    let rules = [];
    for (let i = 0; i < setmRules.length; i++) {
        let ruleObj = getRuleOfSetm(setmRules[i]);
        rules.push(ruleObj);
    }
    return {
        triggerEventMatch,
        dataMergeHandler,
        rules
    }
}

// (interests, steps, match)

var getRuleOfSetm = (setmRule) =>
    setmRule.end(function(queueInfo) {
        let map = queueInfo.getMap();
        let arrMap = queueInfo.getArrMap();
        let match = map["should"].args[0];
        let steps, ruleType;
        let lastBack = map["lookBackAt"];
        if (lastBack) {
            steps = lastBack.args[0];
            ruleType = "bw";
        } else {
            steps = map["lookForwardAt"].args[0];
            ruleType = "pr";
        }
        let interest = arrMap["interest"];
        return {
            steps,
            match,
            ruleType,
            interest
        }
    });


var getDataMergeRule = dataMergeRule => {
    if (!dataMergeRule.mergeHandler) {
        dataMergeRule.mergeHandler = function(triggerEvent) {
            return triggerEvent.data;
        }
    }
    return dataMergeRule.mergeHandler;
}

var getTriggerEventMatch = triggerEventRule =>
    triggerEventRule.end(function(queueInfo) {
        let map = queueInfo.getMap();
        if (map["match"]) {
            var matchRule = (event) =>
                eventTypeChecker.checkEventType(event, [{
                    ctxs: map["match"].args[0],
                    type: map["match"].args[1]
                }]);
        }
        if (!matchRule) {
            var matchRule = function() {
                return 1;
            }
        }
        return matchRule;
    });

export default {
    createManager: () => {
        let setmRules = [];
        let triggerEventRule, dataMergeRule;
        return {
            createSETMRule: () => () => {
                let rule = new SETMRule();
                setmRules.push(rule);
                return rule;
            },
            createTriggerEventRule: () => {
                triggerEventRule = new TriggerEventRule();
                return triggerEventRule;
            },
            createDataMergeRule: () => {
                dataMergeRule = new DataMergeRule();
                return dataMergeRule;
            },
            getRules: () => getRules(setmRules, triggerEventRule, dataMergeRule)
        }
    }
}