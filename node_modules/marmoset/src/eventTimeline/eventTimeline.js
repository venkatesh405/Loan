/**
 *
 * timeline
 * --------------t1----------------t2------------------------t3-------------------
 *                                  |               |
 *                                  |-------------(t2')
 * timeline graph
 *
 * for example: 
 * doubleclick
 * ------(click)------:far------click--:close--click-------:far---(doubleclick)----(click)------
 *                                               |                      |
 *                                               |----------------------|
 *
 * TODO split backward and prospective for better performance
 * 
 *
 * TODO opt coding orginization
 *
 * TODO es6 lint
 */

import adapterManager from "./adapter/adapterManager";
import Forwardline from "forwardline";
import TypeChecker from "typevalidator";
import setSearchRules from "./setSearchRules";

var typeChecker = TypeChecker();

export default () => {
    let timelineConditionMap = {};
    let forwardline = Forwardline();

    var createEventByTimeline = (ctx, type, condition, delay) => {
        typeChecker.checkBatch(["string", "function"], [type, condition]);

        let ruleMap = createRuleMap(condition);
        ruleMap.delay = delay;
        ruleMap.ctx = ctx;

        timelineConditionMap[type] = ruleMap;

        setSearchRules(forwardline, type, ruleMap);
    }

    var createRuleMap = (condition) => {
        let manager = adapterManager.createManager();

        let setmRuleFactory = manager.createSETMRule();
        let triggerEventRule = manager.createTriggerEventRule();
        let dataMergeRule = manager.createDataMergeRule();

        //
        condition(triggerEventRule, setmRuleFactory, dataMergeRule);

        let ruleMap = manager.getRules();
        return ruleMap;
    }

    var triggerTimeline = (event, triggerNewEvent) => {
        // update timeline
        let search = forwardline.store(event).search;

        // trigger new event through timeline
        for (let type in timelineConditionMap) {
            let ruleMap = timelineConditionMap[type];
            // check current event
            if (!ruleMap.triggerEventMatch(event)) {
                continue;
            }
            search(type, (interests) => {
                var result = doMatch(interests, event, ruleMap);

                if (!result) return;
                let ctx = ruleMap.ctx || event.ctx;
                let data = ruleMap.dataMergeHandler(event, interests);
                triggerNewEvent(ctx, type, data);

                forwardline.release();
            }, ruleMap.delay);
        }
    }

    var doMatch = (interests, event, ruleMap) => {
        let rules = ruleMap.rules;
        for (let i = 0; i < rules.length; i++) {
            let res = rules[i].match(interests[i], event);
            if (res === 0) {
                return 0;
            } else if (res === 1) {
                return 1;
            }
        }
        return 0;
    }

    return {
        trigger: {
            name:"timeline",
            action: triggerTimeline
        },
        builders: {
            createEventByTimeline
        }
    }
}