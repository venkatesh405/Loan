/**
 * traceMap
 *      lastEventType
 *      case
 *      nextEvent
 */

import traceRuleAdapter from "./traceRuleAdapter";
import TypeChecker from "typevalidator";

var typeChecker = TypeChecker();

export default () => {
    var traces = [];

    var routes = [];

    var triggerTraceline = (event, triggerNewEvent) => {
        for (let i = 0; i < traces.length; i++) {
            let trace = traces[i];
            let nextEvent = trace.nextEvent;
            if (trace.lastEventType.type === event.type) {
                let res = trace.case(event);
                if (res) {
                    // trigger next
                    triggerNewEvent(nextEvent.ctx, nextEvent.type, nextEvent.data);
                    // trigger before.next
                    let joinEvent = joinToNewEvent(trace, ".", event);
                    triggerNewEvent(joinEvent.ctx, joinEvent.type, joinEvent.data);
                }
            }
        }

        for (let i = 0; i < routes.length; i++) {
            let route = routes[i];
            let nextEvent = route.nextEvent;
            if (route.lastEventType.type === event.type) {
                let res = route.case(event);
                if (res) {
                    // trigger before>next
                    let joinEvent = joinToNewEvent(route, ">", event);
                    triggerNewEvent(joinEvent.ctx, joinEvent.type, joinEvent.data);
                }
            }
        }
    }

    var joinToNewEvent = (trace, jointer, event) => {
        jointer = jointer || ".";
        let type = trace.lastEventType.type + jointer + trace.nextEvent.type;
        let ctx = trace.nextEvent.ctx;
        let data = trace.nextEvent.data;
        if (trace.nextEvent.dataRule) {
            data = trace.nextEvent.dataRule(event);
        }
        return {
            type, ctx, data
        }
    }

    var createEventByTraceline = (condition) => {
        let rules = fetchRules(condition);
        traces = traces.concat(rules);
    }

    var createEventByRoute = (condition) => {
        let rules = fetchRules(condition);
        routes = routes.concat(rules);
    }

    var fetchRules = (condition) => {
        typeChecker.check("function", condition);

        let adapter = traceRuleAdapter();
        let factory = adapter.createRuleFactory();
        condition(factory);
        let rules = adapter.getRules();
        return rules;
    }

    return {
        builders: {
            createEventByTraceline,
            createEventByRoute
        },
        trigger: {
            name: "traceline",
            action: triggerTraceline
        },
        specialMetas: [".", ">"]
    }
}