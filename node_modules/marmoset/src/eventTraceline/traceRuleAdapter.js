/**
 * createTraceEvent((m) => {});
 * 
 * e1.e2      m().happen(ctx1, "e1").inCase((e)=>{}).trigger(ctx2, "e2", data)
 * e1.e2.e3   m().happen(ctx2, "e1.e2").inCase((e)=>{}).trigger(ctx3, "e3", data)
 *
 * lastEventType
 * case
 * nextEvent
 */

import chainStyle from "chainstyle";

var TraceAdapter = chainStyle({
    happen: {
        checkType: ["any", "string"]
    },
    inCase: {
        checkType: ["function"]
    },
    trigger: {
        checkType: ["any", "string"]
    },
    data: {
        checkType: ["function"]
    }
}, {
    getRule: {
        method: function() {
            return this.end(function(queueInfo) {
                let map = queueInfo.getMap();
                return {
                    lastEventType: {
                        ctx: map["happen"].args[0],
                        type: map["happen"].args[1]
                    },
                    case: map["inCase"].args[0],
                    nextEvent: {
                        ctx: map["trigger"].args[0],
                        type: map["trigger"].args[1],
                        data: map["trigger"].args[2],
                        dataRule: map["data"] && map["data"].args[0]
                    }
                }
            });
        }
    }
}, {
    chainRegular: /^happen\.inCase\.trigger(\.data)?$/
});

export default () => {
    let insts = [];
    return {
        createRuleFactory: () => () => {
            let inst = new TraceAdapter();
            for (var name in inst) {}
            insts.push(inst);
            return inst;
        },
        getRules: () => {
            let rules = [];
            for (let i = 0; i < insts.length; i++) {
                let inst = insts[i];
                rules.push(inst.getRule());
            }
            return rules;
        }
    }
}