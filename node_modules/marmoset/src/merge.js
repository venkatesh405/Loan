/**
 * interface of model
 *     name
 *     specialMetas
 *     trigger
 *     onModels
 *     onGroupModels
 */
import Moment from "./moment/moment";
import compatible from "./compatible";

let merge = (map1 = {}, map2 = {}) => {
    for (let name in map2) {
        map1[name] = map2[name];
    }
    return map1;
}

let mergeList = (...y) => {
    if (y.length === 0) return null;
    else if (y.length === 1) return y[0];
    else {
        let top = y[0];
        y.splice(0, 1);
        return merge(top, mergeList.apply(undefined, y));
    }
};

let initMomentByModels = (models) => {
    let specialMetas = [],
        triggerModels = [],
        onModels = [],
        onGroupModels = [];
    for (let i = 0; i < models.length; i++) {
        let model = models[i];
        specialMetas = specialMetas.concat(model.specialMetas || []);
        onModels = onModels.concat(model.onModels || []);
        onGroupModels = onGroupModels.concat(model.onGroupModels || []);
        if (model.trigger) {
            triggerModels.push(model.trigger);
        }
    }
    let moment = Moment({
        specialMetas,
        triggerModels,
        onModels,
        onGroupModels
    });
    return moment;
}

let gatherBuilders = (models) => {
    let buildersList = [];
    for (let i = 0; i < models.length; i++) {
        let builders = models[i].builders;
        if (builders) {
            buildersList.push(builders);
        }
    }
    return buildersList;
}


export default (models) => {
    let moment = initMomentByModels(models);
    return mergeList(compatible(moment), moment,
        mergeList.apply(undefined, gatherBuilders(models)));
}