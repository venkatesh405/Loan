/*******************************************************************
 * used to support plugins
 ********************************************************************/

import TypeChecker from "typevalidator";
import Emmiter from "./emmiter";

let getTypeChecker = specialMetas => TypeChecker({
    "legalTriggerEvent": (v) => {
        for (let i = 0; i < specialMetas.length; i++) {
            if (v.indexOf(specialMetas[i]) !== -1) {
                return false;
            }
        }
        return true;
    },
    "functionList": v => {
        for (let i = 0; i < v.length; i++) {
            let item = v[i];
            if (typeof item !== "function") {
                return false;
            }
        }
        return true;
    }
});

let getFormatType = specialMetas => type => {
    type = type.trim();
    for (let i = 0; i < specialMetas.length; i++) {
        let specialMeta = specialMetas[i];
        let parts = type.split(specialMeta);
        for (let j = 0; j < parts.length; j++) {
            let part = parts[j];
            parts[j] = part.trim();
        }
        type = parts.join(specialMeta);
    }
    return type;
};

let checkOpts = (typeChecker, opts) => {
    typeChecker.checkBatch([
        "falsy | array",
        "falsy | (array & functionList)",
        "falsy | (array & functionList)"
    ], [
        opts.triggerModels,
        opts.onModels,
        opts.onGroupModels
    ]);

    for (let i = 0; i < opts.triggerModels.length; i++) {
        typeChecker.checkBatch([
            "string", "function"
        ], [
            opts.triggerModels[i].name,
            opts.triggerModels[i].action
        ]);
    }
}

/**
 * opts
 *     specialMetas
 *     triggerModels
 *     onModels
 *     onGroupModels
 *
 */
export default (opts = {}) => {
    let emmiter = Emmiter();
    let specialMetas = opts.specialMetas || [];


    // init Type Checker
    let typeChecker = getTypeChecker(specialMetas);
    var formatType = getFormatType(specialMetas);
    //
    checkOpts(typeChecker, opts);

    let triggerModels = opts.triggerModels || [];
    let onModels = opts.onModels || [];
    let onGroupModels = opts.onGroupModels || [];
    /**
     * used to trigger a event, and send data through event.
     */
    var trigger = (ctx, type, data) => {
        typeChecker.check("string & legalTriggerEvent", type);
        let eventStack = [];
        triggerEvent(ctx, type, data, eventStack);
    }

    var triggerEvent = (ctx, type, data, eventStack, modelName) => {
        // trigger this event
        let event = emmiter.trigger(ctx, type, data);
        eventStack.push({
            event: event,
            source: {
                modelName
            }
        });

        let triggerThrough = (name) => (ctx, type, data) => {
            triggerEvent(ctx, type, data, eventStack, name);
        }

        // trigger models
        for (let i = 0; i < triggerModels.length; i++) {
            let triggerModel = triggerModels[i];
            triggerModel.action(event, triggerThrough(triggerModel.name), eventStack);
        }
    }

    var on = (ctx, type, handler) => {
        typeChecker.checkBatch(["string", "function"], [type, handler]);
        type = formatType(type);

        // grammer for on, when on create events
        for (let i = 0; i < onModels.length; i++) {
            let onModel = onModels[i];
            onModel(ctx, type, handler);
        }
        return emmiter.on(ctx, type, handler);
    }

    var onGroup = (ctxs, type, handler) => {
        typeChecker.checkBatch(["string", "function"], [type, handler]);
        type = formatType(type);
        let last = ctxs[ctxs.length - 1];

        // grammer for onGroup, when onGroup create rules
        for (let i = 0; i < onGroupModels.length; i++) {
            let onGroupModel = onGroupModels[i];
            onGroupModel(ctxs, type, handler);
        }
        return emmiter.on(last, type, handler);
    }

    return {
        trigger,
        on,
        onGroup,
        off: emmiter.off
    }
}