import Marmoset from "../../index";
import assert from "assert";


var createClick = (ctx) => {
    let marmoset = Marmoset();
    marmoset.createEventByTimeline(ctx, "click", (start, m, dataMerge) => {

        start.match([ctx], "mouseup");

        m().interest([ctx], ["mousedown", "mouseup"]).lookBackAt(1).should((e) => {
            if (!e) return 0;
            if (e.type == "mouseup") return 0;
            if (e.type == "mousedown") return 1;
            return 0;
        });

        dataMerge.merge((cur, interestedpasses, interestedforwards) => {
            return cur.data + interestedpasses[0].data;
        })
    }, 50);
    return marmoset;
}

describe("timeline", () => {

    it("#createEventByTimeline: click base", (done) => {
        let ctx = {};
        let marmoset = createClick(ctx);

        marmoset.on(ctx, "click", (e) => {
            done();
        });

        marmoset.trigger(ctx, "mousedown", 1);
        marmoset.trigger(ctx, "mouseup", 2);
        marmoset.trigger(ctx, "mouseup", 3);
    });

    it("#createEventByTimeline: click && no delay", (done) => {
        let ctx = {};
        let marmoset = createClick(ctx);

        marmoset.on(ctx, "click", (e) => {
            done();
        });

        marmoset.trigger(ctx, "mousedown", 1);
        marmoset.trigger(ctx, "mouseup", 2);
        marmoset.trigger(ctx, "mouseup", 3);
    });

    it("#createEventByTimeline: click & merge data", (done) => {
        let ctx = {};
        let marmoset = createClick(ctx);

        marmoset.on(ctx, "click", (e) => {
            assert.equal(e.data, 3);
            done();
        });


        marmoset.trigger(ctx, "touch", 5);
        marmoset.trigger(ctx, "mousedown", 1);
        marmoset.trigger(ctx, "mouseup", 2);
        marmoset.trigger(ctx, "mouseup", 3);
    });

    it("#wrong api order", (done) => {
        let marmoset = Marmoset();
        let ctx = {};

        try {
            marmoset.createEventByTimeline(ctx, "b", (cur, m) => {

                cur.match(null, "a");

                m().lookBackAt(1).interest([ctx], "a").should((cur) => {
                    if (cur) return 0;
                    return -1;
                });

            }, 50);
        } catch (e) {
            assert.equal(e.toString().indexOf("is not match for regular") !== -1, true)
            done();
        }
    });

    it("#wrong type for should", (done) => {
        let marmoset = Marmoset();
        let ctx = {};
        try {
            marmoset.createEventByTimeline(ctx, "b", (cur, m) => {

                cur.match(null, "a");

                m().interest([ctx], "a").lookBackAt(1).should("ok!");

            }, 50);
        } catch (e) {
            console.log(e.toString());
            assert.equal(e.toString().indexOf("type checking fail") !== -1, true)
            done();
        }
    });
});